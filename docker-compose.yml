# ===========================================================================
# Docker Compose Configuration for Sure
# ===========================================================================
#
# This is the production-ready Docker Compose file for self-hosting Sure.
# It includes all necessary services and configurations.
#
# Usage:
# ------
#
# 1. Copy this file to your deployment directory
# 2. Create a .env file with your configuration (see .env.example)
# 3. Run: docker compose up -d
#
# For detailed setup instructions, see:
# https://github.com/we-promise/sure/blob/main/docs/hosting/docker.md
#

x-db-env: &db_env
  POSTGRES_USER: ${POSTGRES_USER:-sure_user}
  POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-sure_password}
  POSTGRES_DB: ${POSTGRES_DB:-sure_production}

x-rails-env: &rails_env
  <<: *db_env
  # Rails Environment
  RAILS_ENV: ${RAILS_ENV:-production}
  SECRET_KEY_BASE: ${SECRET_KEY_BASE}
  RAILS_MASTER_KEY: ${RAILS_MASTER_KEY}
  
  # Self-hosting configuration
  SELF_HOSTED: "true"
  SELF_HOSTING_ENABLED: "true"
  
  # SSL Configuration (set to "true" if using reverse proxy with SSL)
  RAILS_FORCE_SSL: ${RAILS_FORCE_SSL:-false}
  RAILS_ASSUME_SSL: ${RAILS_ASSUME_SSL:-false}
  
  # Database connection
  DB_HOST: db
  DB_PORT: 5432
  DATABASE_URL: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}
  
  # Redis connection
  REDIS_URL: redis://redis:6379/1
  
  # Application host (set your domain or IP)
  HOST: ${HOST:-localhost}
  
  # Optional: OpenAI (for AI features - will incur costs)
  # Make sure you have set appropriate spend limits before enabling
  OPENAI_ACCESS_TOKEN: ${OPENAI_ACCESS_TOKEN:-}
  
  # Optional: Email configuration
  SMTP_HOST: ${SMTP_HOST:-}
  SMTP_PORT: ${SMTP_PORT:-}
  SMTP_USERNAME: ${SMTP_USERNAME:-}
  SMTP_PASSWORD: ${SMTP_PASSWORD:-}
  SMTP_TLS_ENABLED: ${SMTP_TLS_ENABLED:-false}
  
  # Optional: Stripe (for payments)
  STRIPE_PUBLISHABLE_KEY: ${STRIPE_PUBLISHABLE_KEY:-}
  STRIPE_SECRET_KEY: ${STRIPE_SECRET_KEY:-}
  
  # Optional: Plaid (for bank sync)
  PLAID_CLIENT_ID: ${PLAID_CLIENT_ID:-}
  PLAID_SECRET: ${PLAID_SECRET:-}
  PLAID_ENV: ${PLAID_ENV:-sandbox}

services:
  web:
    image: ghcr.io/we-promise/sure:latest
    container_name: sure-web
    volumes:
      - app-storage:/rails/storage
    ports:
      - "${PORT:-3000}:3000"
    restart: unless-stopped
    environment:
      <<: *rails_env
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - sure_net
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/up"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  worker:
    image: ghcr.io/we-promise/sure:latest
    container_name: sure-worker
    command: bundle exec sidekiq
    volumes:
      - app-storage:/rails/storage
    restart: unless-stopped
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      <<: *rails_env
    networks:
      - sure_net

  db:
    image: postgres:16
    container_name: sure-db
    restart: unless-stopped
    volumes:
      - postgres-data:/var/lib/postgresql/data
    environment:
      <<: *db_env
    networks:
      - sure_net
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-sure_user} -d ${POSTGRES_DB:-sure_production}"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: sure-redis
    restart: unless-stopped
    volumes:
      - redis-data:/data
    command: redis-server --appendonly yes
    networks:
      - sure_net
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5

volumes:
  app-storage:
    driver: local
  postgres-data:
    driver: local
  redis-data:
    driver: local

networks:
  sure_net:
    driver: bridge
